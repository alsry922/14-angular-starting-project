### ë²ˆì—­

---

#### 1
**So what if you don't have static data,**  
**but dynamic data, as it's the case here**  
**where the data we fetch depends on a route parameter.**  
ë§Œì•½ ì •ì  ë°ì´í„°ê°€ ì•„ë‹ˆë¼  
ë¼ìš°íŠ¸ ë§¤ê°œë³€ìˆ˜ì— ì˜ì¡´í•˜ëŠ”  
ë™ì  ë°ì´í„°ë¥¼ ê°€ì ¸ì™€ì•¼ í•œë‹¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œìš”?

#### 2
**Well, the Angular router also helps you with that,**  
**though not with help of the data property.**  
**Instead, you can add another property**  
**to your route configuration**  
**and that would be the resolve property.**  
Angular ë¼ìš°í„°ëŠ”  
ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë° ë„ì›€ì„ ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ë‹¤ë§Œ, `data` ì†ì„±ì´ ì•„ë‹ˆë¼  
`resolve` ì†ì„±ì„  
ë¼ìš°íŠ¸ êµ¬ì„±ì— ì¶”ê°€í•˜ë©´ ë©ë‹ˆë‹¤.

#### 3
**And resolve now works a bit like data,**  
**but for dynamic instead of static data**  
**because resolve wants an object here**  
**where you can have key value pairs,**  
**where the keys are totally up to you.**  
`resolve`ëŠ” `data`ì™€ ì•½ê°„ ë¹„ìŠ·í•˜ê²Œ ë™ì‘í•˜ì§€ë§Œ,  
ì •ì  ë°ì´í„°ê°€ ì•„ë‹Œ ë™ì  ë°ì´í„°ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.  
`resolve`ì—ëŠ” í‚¤-ê°’ ìŒì´ í¬í•¨ëœ ê°ì²´ë¥¼  
ì „ë‹¬í•  ìˆ˜ ìˆìœ¼ë©°,  
í‚¤ëŠ” ì›í•˜ëŠ” ëŒ€ë¡œ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

#### 4
**But the values then are not static data like they are**  
**in this data object.**  
**But instead the values now must be valid angular resolvers,**  
**which in modern Angular are simply functions.**  
í•˜ì§€ë§Œ ê°’ì€  
`data` ê°ì²´ì²˜ëŸ¼ ì •ì  ë°ì´í„°ê°€ ì•„ë‹™ë‹ˆë‹¤.  
ëŒ€ì‹ , ê°’ì€ ìœ íš¨í•œ Angular `resolver`ì—¬ì•¼ í•˜ë©°,  
ìµœì‹  Angularì—ì„œëŠ” ë‹¨ìˆœíˆ í•¨ìˆ˜ë¡œ êµ¬í˜„ë©ë‹ˆë‹¤.

#### 5
**In older versions of Angular, you would use classes instead**  
**and the next lecture will take care about that.**  
**Here we'll focus on the more modern style.**  
ì´ì „ Angular ë²„ì „ì—ì„œëŠ”  
í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•´ì•¼ í–ˆì§€ë§Œ,  
ì´ ê°•ì˜ì—ì„œëŠ” ìµœì‹  ìŠ¤íƒ€ì¼ì—  
ì´ˆì ì„ ë§ì¶”ê² ìŠµë‹ˆë‹¤.

---

#### 6
**Therefore, for example here, we could go**  
**to this user tasks component file here**  
**and add such a resolver function there,**  
**though you could add it in any file you want.**  
**It doesn't have to be done there.**  
ë”°ë¼ì„œ, ì˜ˆë¥¼ ë“¤ì–´ ì—¬ê¸°ì„œ  
`UserTasksComponent` íŒŒì¼ë¡œ ì´ë™í•´  
`resolver` í•¨ìˆ˜ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ë¬¼ë¡ , ë‹¤ë¥¸ íŒŒì¼ì— ì¶”ê°€í•´ë„ ìƒê´€ì—†ìŠµë‹ˆë‹¤.

#### 7
**Therefore, what we could do is we could go**  
**to this user tasks component, TypeScript file,**  
**and then there outside of that class,**  
**we could export a function**  
**that could be named resolveUserName,**  
**though the name is up to you.**  
ì—¬ê¸°ì„œ í•  ìˆ˜ ìˆëŠ” ì‘ì—…ì€  
`UserTasksComponent` TypeScript íŒŒì¼ë¡œ ì´ë™í•˜ì—¬  
í•´ë‹¹ í´ë˜ìŠ¤ ì™¸ë¶€ì—  
`resolveUserName`ì´ë¼ëŠ” í•¨ìˆ˜ë¥¼  
ë‚´ë³´ë‚´ëŠ” ê²ƒì…ë‹ˆë‹¤.  
ë¬¼ë¡ , í•¨ìˆ˜ ì´ë¦„ì€ ì›í•˜ëŠ” ëŒ€ë¡œ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

#### 8
**I'm naming it like this**  
**because I plan on using it as a resolver function**  
**for this component, for this route here.**  
ì´ë¦„ì„ ì´ë ‡ê²Œ ì„¤ì •í•œ ì´ìœ ëŠ”  
ì´ ì»´í¬ë„ŒíŠ¸ì™€ ë¼ìš°íŠ¸ë¥¼ ìœ„í•œ  
`resolver` í•¨ìˆ˜ë¡œ ì‚¬ìš©í•  ê³„íšì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

#### 9
**And because I plan to fetch the username,**  
**because that's also**  
**what we're doing here in ngOnInit it at the moment.**  
ê·¸ë¦¬ê³  ì—¬ê¸°ì„œ  
`ngOnInit`ì—ì„œ ìˆ˜í–‰í•˜ê³  ìˆëŠ” ê²ƒì²˜ëŸ¼  
`username`ì„ ê°€ì ¸ì˜¤ë ¤ëŠ” ê³„íš ë•Œë¬¸ì…ë‹ˆë‹¤.

---

#### 10
**So therefore here we can define this function**  
**and this function should then be a function that is accepted**  
**by Angular in that resolve array.**  
ë”°ë¼ì„œ ì—¬ê¸°ì—ì„œ  
ì´ í•¨ìˆ˜ë¥¼ ì •ì˜í•  ìˆ˜ ìˆìœ¼ë©°,  
ì´ í•¨ìˆ˜ëŠ” `resolve` ë°°ì—´ì—ì„œ Angularì— ì˜í•´  
í—ˆìš©ë˜ëŠ” í•¨ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.

#### 11
**Now, to be accepted there, it must have a certain signature.**  
**And to ensure this signature, I'll actually convert it**  
**to a function that's created slightly different**  
**by actually creating a constant or variable**  
**named resolveUserName in which I then store**  
**a function like this.**  
í—ˆìš©ë˜ë ¤ë©´ í•¨ìˆ˜ì—  
íŠ¹ì •í•œ ì‹œê·¸ë‹ˆì²˜ê°€ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.  
ì´ ì‹œê·¸ë‹ˆì²˜ë¥¼ ë³´ì¥í•˜ê¸° ìœ„í•´  
`resolveUserName`ì´ë¼ëŠ” ìƒìˆ˜ë‚˜ ë³€ìˆ˜ë¥¼ ìƒì„±í•˜ê³ ,  
ê·¸ ì•ˆì— í•¨ìˆ˜ë¥¼ ì €ì¥í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ  
í•¨ìˆ˜ë¥¼ ìƒì„±í•˜ê² ìŠµë‹ˆë‹¤.

#### 12
**You can do that in JavaScript and TypeScript,**  
**but this notation now allows me to assign a type**  
**to that constant, which then allows me to ensure**  
**that I set up the correct function signature**  
**because the type of this function should be resolveFn**  
**for resolve function.**  
JavaScriptì™€ TypeScriptì—ì„œ  
ì´ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ì´ í‘œê¸°ë²•ì„ ì‚¬ìš©í•˜ë©´ ìƒìˆ˜ì—  
íƒ€ì…ì„ í• ë‹¹í•  ìˆ˜ ìˆìœ¼ë©°,  
ì´ë¥¼ í†µí•´ ì˜¬ë°”ë¥¸ í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ë¥¼  
ì„¤ì •í–ˆëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ì´ í•¨ìˆ˜ì˜ íƒ€ì…ì€ `resolveFn`ì´ì–´ì•¼ í•©ë‹ˆë‹¤.

#### 13
**And that is a type that is imported from @angular/router.**  
**Now with that imported and assigned here,**  
**we have to set up this function**  
**such that it adheres to this type definition**  
**and it does adhere to that if it accepts two parameters**  
**where the first one is the activated route,**  
**which is of type ActivatedRouteSnapshot.**  
ì´ íƒ€ì…ì€ `@angular/router`ì—ì„œ  
ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ê°€ì ¸ì˜¨ í›„, í•¨ìˆ˜ê°€ ì´ íƒ€ì… ì •ì˜ë¥¼ ì¤€ìˆ˜í•˜ë„ë¡  
ì„¤ì •í•´ì•¼ í•©ë‹ˆë‹¤.  
ë‘ ê°œì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ë°›ì•„ì•¼ í•˜ë©°,  
ì²« ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ëŠ”  
`ActivatedRouteSnapshot` íƒ€ì…ì˜  
`activatedRoute`ì…ë‹ˆë‹¤.

### ë²ˆì—­ (ê³„ì†)

---

#### 14
**So that's of course similar**  
**to the activated route we injected earlier in this section,**  
**but now it's just that snapshot, which I already mentioned.**  
**So that snapshot where you can't subscribe**  
**to parameters and so on,**  
**because this resolver will be called**  
**for every navigation action.**  
ì´ëŠ” ì´ì „ì— ì´ ì„¹ì…˜ì—ì„œ  
ì£¼ì…í–ˆë˜ `activatedRoute`ì™€ ìœ ì‚¬í•˜ì§€ë§Œ,  
ì´ë²ˆì—ëŠ” ì œê°€ ì´ë¯¸ ì–¸ê¸‰í•œ  
`snapshot`ì…ë‹ˆë‹¤.  
ì´ `snapshot`ì—ì„œëŠ”  
ë§¤ê°œë³€ìˆ˜ ë“±ì— ëŒ€í•´  
êµ¬ë…í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.  
ì™œëƒí•˜ë©´ ì´ `resolver`ëŠ”  
ëª¨ë“  ë„¤ë¹„ê²Œì´ì…˜ ë™ì‘ì—ì„œ í˜¸ì¶œë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

#### 15
**So every time this route gets active,**  
**this resolver function will be called**  
**and it will then receive the latest snapshot**  
**that describes this activated route.**  
ë”°ë¼ì„œ ì´ ë¼ìš°íŠ¸ê°€ í™œì„±í™”ë  ë•Œë§ˆë‹¤  
ì´ `resolver` í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ê³ ,  
ì´ í™œì„±í™”ëœ ë¼ìš°íŠ¸ë¥¼ ì„¤ëª…í•˜ëŠ”  
ìµœì‹  `snapshot`ì„ ë°›ê²Œ ë©ë‹ˆë‹¤.

#### 16
**That's why there is no reason to subscribe to it here**  
**because it will be re-executed.**  
**This function will be re-executed**  
**whenever the route becomes active,**  
**even if it already was active.**  
ê·¸ë˜ì„œ ì—¬ê¸°ì—ì„œëŠ”  
êµ¬ë…ì„ ì„¤ì •í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.  
ì´ í•¨ìˆ˜ëŠ” ë¼ìš°íŠ¸ê°€ í™œì„±í™”ë  ë•Œë§ˆë‹¤,  
ì‹¬ì§€ì–´ ì´ë¯¸ í™œì„±í™”ëœ ê²½ìš°ì—ë„  
ë‹¤ì‹œ ì‹¤í–‰ë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

#### 17
**So it will be called again if the route parameter changes,**  
**for example.**  
ì˜ˆë¥¼ ë“¤ì–´, ë¼ìš°íŠ¸ ë§¤ê°œë³€ìˆ˜ê°€ ë³€ê²½ë˜ë©´  
ì´ í•¨ìˆ˜ê°€ ë‹¤ì‹œ í˜¸ì¶œë©ë‹ˆë‹¤.

---

#### 18
**The second parameter**  
**that should be accepted here is the current router state,**  
**which is of type RouterStateSnapshot.**  
**So that's another type which just like**  
**ActivatedRouteSnapshot must be imported from Angular router.**  
ì—¬ê¸°ì„œ ë°›ì•„ì•¼ í•  ë‘ ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ëŠ”  
í˜„ì¬ì˜ ë¼ìš°í„° ìƒíƒœì´ë©°,  
`RouterStateSnapshot` íƒ€ì…ì…ë‹ˆë‹¤.  
ì´ê²ƒë„ `ActivatedRouteSnapshot`ì²˜ëŸ¼  
`@angular/router`ì—ì„œ ê°€ì ¸ì™€ì•¼ í•©ë‹ˆë‹¤.

#### 19
**Now in this resolver function, we then also need**  
**to return something.**  
**We need to return the data that should be resolved**  
**by that function,**  
**and that of course should be the username,**  
**which should be fetched basically as we're doing it here**  
**with help of the user's service.**  
ì´ì œ ì´ `resolver` í•¨ìˆ˜ì—ì„œ  
ë¬´ì–¸ê°€ë¥¼ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.  
ì´ í•¨ìˆ˜ì—ì„œ í•´ê²°í•´ì•¼ í•  ë°ì´í„°ë¥¼  
ë°˜í™˜í•´ì•¼ í•˜ë©°,  
ê·¸ ë°ì´í„°ëŠ” ë‹¹ì—°íˆ `username`ì´ì–´ì•¼ í•©ë‹ˆë‹¤.  
ì´ëŠ” ì—¬ê¸°ì—ì„œ `usersService`ë¥¼ ì‚¬ìš©í•˜ì—¬  
ê°€ì ¸ì˜¤ëŠ” ê²ƒê³¼ ë™ì¼í•©ë‹ˆë‹¤.

#### 20
**But this service is injected into this class here.**  
**This resolver function here, however,**  
**is outside of this class.**  
**It's not a class method and therefore**  
**it doesn't have access to that service.**  
í•˜ì§€ë§Œ ì´ ì„œë¹„ìŠ¤ëŠ”  
í˜„ì¬ í´ë˜ìŠ¤ì— ì£¼ì…ë˜ì–´ ìˆìŠµë‹ˆë‹¤.  
ê·¸ëŸ¬ë‚˜ ì´ `resolver` í•¨ìˆ˜ëŠ”  
í´ë˜ìŠ¤ ì™¸ë¶€ì— ìˆìŠµë‹ˆë‹¤.  
í´ë˜ìŠ¤ ë©”ì„œë“œê°€ ì•„ë‹ˆë¯€ë¡œ  
ì´ ì„œë¹„ìŠ¤ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

---

#### 21
**But thankfully Angular allows you to inject things**  
**like services into these resolver functions as well**  
**with help of this inject function.**  
**Not with help of the constructor**  
**because functions don't have constructors,**  
**but we can call the inject function here**  
**in that resolver function**  
**and inject the UsersService.**  
í•˜ì§€ë§Œ ë‹¤í–‰íˆë„ AngularëŠ”  
ì´ `inject` í•¨ìˆ˜ë¥¼ í†µí•´  
ì´ëŸ¬í•œ `resolver` í•¨ìˆ˜ì—  
ì„œë¹„ìŠ¤ ê°™ì€ ê²ƒë“¤ì„ ì£¼ì…í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.  
ìƒì„±ìë¥¼ ì‚¬ìš©í•  ìˆ˜ëŠ” ì—†ì§€ë§Œ,  
ì´ `resolver` í•¨ìˆ˜ ë‚´ì—ì„œ  
`inject` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬  
`UsersService`ë¥¼ ì£¼ì…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

#### 22
**Angular will make sure that this works.**  
**So that gives us access to that UsersService**  
**in this resolver function as well.**  
AngularëŠ” ì´ê²ƒì´ ì‘ë™í•˜ë„ë¡ ë³´ì¥í•©ë‹ˆë‹¤.  
ë”°ë¼ì„œ ì´ `resolver` í•¨ìˆ˜ì—ì„œë„  
`UsersService`ì— ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

#### 23
**And with that injected, we can then get hold of**  
**that user name**  
**by basically executing the same code we have up here**  
**without this keyword since we're not in a class now.**  
ì´ì œ ì£¼ì…ì´ ì™„ë£Œë˜ì—ˆìœ¼ë¯€ë¡œ,  
ì´ì „ì— ì‘ì„±í•œ ë™ì¼í•œ ì½”ë“œë¥¼  
í´ë˜ìŠ¤ ë‚´ë¶€ê°€ ì•„ë‹ˆë¯€ë¡œ  
`this` í‚¤ì›Œë“œ ì—†ì´ ì‹¤í–‰í•˜ì—¬  
`username`ì„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

#### 24
**But now we can call UsersService.users.find,**  
**but we also need to get access to the route parameters.**  
**But we thankfully do get access to that with help of**  
**that ActivatedRouteSnapshot here.**  
ì´ì œ `UsersService.users.find`ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆì§€ë§Œ,  
ë¼ìš°íŠ¸ ë§¤ê°œë³€ìˆ˜ì—ë„ ì ‘ê·¼í•´ì•¼ í•©ë‹ˆë‹¤.  
ë‹¤í–‰íˆë„ ì—¬ê¸°ì„œ `ActivatedRouteSnapshot`ì„  
ì‚¬ìš©í•˜ì—¬ í•´ë‹¹ ê°’ì— ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

#### 25
**So we can use our activatedRoute here**  
**because that has a paramMap property**  
**which has that get method.**  
**So that's how we can get hold of that.**  
ë”°ë¼ì„œ `activatedRoute`ë¥¼ ì‚¬ìš©í•˜ì—¬  
`paramMap` ì†ì„±ì— ì ‘ê·¼í•˜ê³ ,  
`get` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ì´ë ‡ê²Œ í•˜ë©´ í•´ë‹¹ ê°’ì„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

#### 26
**And as I mentioned before,**  
**this resolver function will be re executed**  
**every time the route parameter changes.**  
**So therefore we don't have to set up a subscription**  
**or anything like that here.**  
**Instead it will be re executed automatically by Angular**  
**whenever we load a different user.**  
ì•ì„œ ì–¸ê¸‰í–ˆë“¯ì´,  
ì´ `resolver` í•¨ìˆ˜ëŠ”  
ë¼ìš°íŠ¸ ë§¤ê°œë³€ìˆ˜ê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤  
ë‹¤ì‹œ ì‹¤í–‰ë©ë‹ˆë‹¤.  
ë”°ë¼ì„œ êµ¬ë…ì„ ì„¤ì •í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.  
ëŒ€ì‹  ë‹¤ë¥¸ ì‚¬ìš©ìë¥¼ ë¡œë“œí•  ë•Œë§ˆë‹¤  
Angularì— ì˜í•´ ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì‹¤í–‰ë©ë‹ˆë‹¤.

#### 27
**And with that, we therefore then got the username**  
**and we can return that here in that resolver function.**  
ê·¸ ê²°ê³¼, `username`ì„ ì–»ì„ ìˆ˜ ìˆìœ¼ë©°,  
ì´ë¥¼ `resolver` í•¨ìˆ˜ì—ì„œ  
ë°˜í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ë²ˆì—­ (ê³„ì†)

---

#### 28
**Now, TypeScript is still complaining here**  
**because actually it wants some extra information**  
**on that resolveFn type regarding the return value**  
**of this function.**  
ì§€ê¸ˆ TypeScriptê°€ ì—¬ì „íˆ ê²½ê³ ë¥¼ í‘œì‹œí•˜ëŠ” ì´ìœ ëŠ”  
`resolveFn` íƒ€ì…ì—ì„œ ì´ í•¨ìˆ˜ì˜ ë°˜í™˜ ê°’ì— ëŒ€í•œ  
ì¶”ê°€ ì •ë³´ê°€ í•„ìš”í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

#### 29
**So you should add angle brackets here**  
**and then define the shape**  
**of the data you are returning here.**  
**And in my case, it's a simple string.**  
ë”°ë¼ì„œ ì—¬ê¸°ì— êº¾ì‡ ê´„í˜¸( `<`ì™€ `>` )ë¥¼ ì¶”ê°€í•˜ê³ ,  
ë°˜í™˜í•  ë°ì´í„°ì˜ êµ¬ì¡°ë¥¼ ì •ì˜í•´ì•¼ í•©ë‹ˆë‹¤.  
ì œ ê²½ìš°ì—ëŠ” ê°„ë‹¨íˆ ë¬¸ìì—´ì…ë‹ˆë‹¤.

#### 30
**So between these angle brackets, in this case here,**  
**you should simply put string**  
**and that's then the finished resolver function.**  
ë”°ë¼ì„œ ì´ ê²½ìš° êº¾ì‡ ê´„í˜¸ ì•ˆì— `string`ì„  
ì¶”ê°€í•˜ë©´, `resolver` í•¨ìˆ˜ê°€ ì™„ì„±ë©ë‹ˆë‹¤.

---

#### 31
**The question now just is how you make that data**  
**that's fetched by this function available**  
**to this component class here and to the overall component,**  
**therefore, and the answer is essentially just**  
**as it was the case here with that static data.**  
ì´ì œ ì´ í•¨ìˆ˜ì—ì„œ ê°€ì ¸ì˜¨ ë°ì´í„°ë¥¼  
ì´ ì»´í¬ë„ŒíŠ¸ í´ë˜ìŠ¤ì™€ ì „ì²´ ì»´í¬ë„ŒíŠ¸ì—ì„œ  
ì–´ë–»ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”ì§€ê°€ ë¬¸ì œì…ë‹ˆë‹¤.  
ê·¸ë¦¬ê³  ë‹µì€  
ì •ì  ë°ì´í„°ì—ì„œ ì‚¬ìš©í–ˆë˜ ë°©ë²•ê³¼  
ë³¸ì§ˆì ìœ¼ë¡œ ë™ì¼í•©ë‹ˆë‹¤.

#### 32
**If you have this ComponentInputBinding enabled,**  
**your resolved data will be made available**  
**to that target component as an input property.**  
`ComponentInputBinding`ì´ í™œì„±í™”ëœ ê²½ìš°,  
`resolver`ë¥¼ í†µí•´ ê°€ì ¸ì˜¨ ë°ì´í„°ëŠ”  
ëŒ€ìƒ ì»´í¬ë„ŒíŠ¸ì—ì„œ ì…ë ¥ ì†ì„±ìœ¼ë¡œ  
ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

#### 33
**So therefore what we should do is go to our route definition**  
**and then here in this resolve object,**  
**you can pick any key name of your choice like username.**  
**As a value, you now should point at this resolver function,**  
**so not at some static data.**  
**Therefore the value here is resolveUserName.**  
ë”°ë¼ì„œ ë¼ìš°íŠ¸ ì •ì˜ë¡œ ì´ë™í•´  
`resolve` ê°ì²´ì—ì„œ ì›í•˜ëŠ” í‚¤ ì´ë¦„(ì˜ˆ: `username`)ì„  
ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.  
ê°’ìœ¼ë¡œëŠ” ì •ì  ë°ì´í„°ê°€ ì•„ë‹Œ  
`resolver` í•¨ìˆ˜ë¥¼ ì§€ì •í•´ì•¼ í•©ë‹ˆë‹¤.  
ë”°ë¼ì„œ ê°’ì€ `resolveUserName`ì´ ë©ë‹ˆë‹¤.

#### 34
**And this now should not be executed.**  
**You don't have parentheses here.**  
**Instead you just point at this function**  
**because Angular will execute it for you.**  
ê·¸ë¦¬ê³  ì´ í•¨ìˆ˜ëŠ” ì‹¤í–‰ë˜ì§€ ì•Šì•„ì•¼ í•©ë‹ˆë‹¤.  
ë”°ë¼ì„œ ê´„í˜¸ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³ ,  
ê·¸ëƒ¥ í•¨ìˆ˜ë¥¼ ì°¸ì¡°í•´ì•¼ í•©ë‹ˆë‹¤.  
Angularê°€ ìë™ìœ¼ë¡œ ì‹¤í–‰í•´ ì¤„ ê²ƒì…ë‹ˆë‹¤.

---

#### 35
**And the value returned by that resolver function**  
**will then be made available**  
**to this component through an input with this name.**  
**So in my case with the name userName.**  
ê·¸ë¦¬ê³  `resolver` í•¨ìˆ˜ì—ì„œ ë°˜í™˜ëœ ê°’ì€  
í•´ë‹¹ ì´ë¦„(ì´ ê²½ìš° `userName`)ì˜ ì…ë ¥ ì†ì„±ì„ í†µí•´  
ì´ ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤.

#### 36
**Therefore what we can and should do as a next and final step**  
**is go back to that user tasks component.**  
**And there we can get rid of ngOnInit**  
**because that entire data fetching now no longer**  
**has to be performed in here.**  
ë”°ë¼ì„œ ë‹¤ìŒìœ¼ë¡œ í•´ì•¼ í•  ë§ˆì§€ë§‰ ë‹¨ê³„ëŠ”  
`UserTasksComponent`ë¡œ ëŒì•„ê°€ëŠ” ê²ƒì…ë‹ˆë‹¤.  
ê·¸ëŸ° ë‹¤ìŒ `ngOnInit`ì„ ì œê±°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ì™œëƒí•˜ë©´ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°ê°€  
ë” ì´ìƒ ì´ê³³ì—ì„œ ìˆ˜í–‰ë  í•„ìš”ê°€ ì—†ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

#### 37
**Instead we can now simply accept an input**  
**and we can get rid of all this code here as well, therefore,**  
**all of this and just change our username here, this property**  
**to be an input for example, by using the input function**  
**or by using the input decorator,**  
**that of course would also work,**  
**and it can be a required input here.**  
ëŒ€ì‹  ì´ì œ ë‹¨ìˆœíˆ ì…ë ¥ê°’ì„ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ë”°ë¼ì„œ ì´ ëª¨ë“  ì½”ë“œë¥¼ ì œê±°í•˜ê³ ,  
`username` ì†ì„±ì„ ì…ë ¥ê°’ìœ¼ë¡œ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ì˜ˆë¥¼ ë“¤ì–´, `input` í•¨ìˆ˜ë‚˜  
`Input` ë°ì½”ë ˆì´í„°ë¥¼ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤.  
ê·¸ë¦¬ê³  ì´ ì†ì„±ì„ í•„ìˆ˜ ì…ë ¥ê°’ìœ¼ë¡œ  
ì„¤ì •í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

---

#### 38
**And I know that I'll get a value of type string.**  
**So that's how we could set this up.**  
**And this implements OnInit thing here also should go**  
**and we can and should it then all remove these unused**  
**imports like that.**  
ê·¸ë¦¬ê³  ì´ ê°’ì´ ë¬¸ìì—´ íƒ€ì…ì„ì„ ì•Œê¸° ë•Œë¬¸ì—  
ì´ë ‡ê²Œ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
`OnInit` êµ¬í˜„ë„ ì œê±°í•´ì•¼ í•˜ë©°,  
ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” `import` ë¬¸ë„  
ëª¨ë‘ ì œê±°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

#### 39
**And with that we got a much leaner component now.**  
**It barely contains any code as you can tell.**  
ì´ì œ í›¨ì”¬ ê°„ê²°í•œ ì»´í¬ë„ŒíŠ¸ë¥¼  
ì–»ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.  
ë³´ì‹œë‹¤ì‹œí”¼ ê±°ì˜ ì½”ë“œê°€  
í¬í•¨ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.

#### 40
**Instead that's not all in that resolver function.**  
**And that function could theoretically also be stored**  
**in some other file**  
**and therefore we outsourced**  
**that data fetching task from the component to the resolver,**  
**which can be an elegant way**  
**of getting your component data when using routing.**  
ëŒ€ì‹  ëŒ€ë¶€ë¶„ì˜ ì‘ì—…ì€  
`resolver` í•¨ìˆ˜ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.  
ê·¸ë¦¬ê³  ì´ í•¨ìˆ˜ëŠ” ì´ë¡ ì ìœ¼ë¡œ ë‹¤ë¥¸ íŒŒì¼ì—  
ì €ì¥í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.  
ë”°ë¼ì„œ ì»´í¬ë„ŒíŠ¸ì—ì„œ `resolver`ë¡œ  
ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì‘ì—…ì„ ë¶„ë¦¬í–ˆìœ¼ë©°,  
ë¼ìš°íŒ…ì„ ì‚¬ìš©í•  ë•Œ  
ì»´í¬ë„ŒíŠ¸ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ëŠ”  
íš¨ìœ¨ì ì¸ ë°©ë²•ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

#### 41
**Now since I'm using the input function here,**  
**username will be a signal**  
**and therefore we should call it as such in our template**  
**to get that signal value.**  
ì§€ê¸ˆ ì´ê³³ì—ì„œ `input` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ê³  ìˆê¸° ë•Œë¬¸ì—  
`username`ì€ `Signal`ì´ ë©ë‹ˆë‹¤.  
ë”°ë¼ì„œ í…œí”Œë¦¿ì—ì„œ í•´ë‹¹ `Signal` ê°’ì„  
ì–»ê¸° ìœ„í•´ í˜¸ì¶œí•´ì•¼ í•©ë‹ˆë‹¤.

#### 42
**But with that done, if you save everything,**  
**you should be able to go back**  
**and still see that username here.**  
**And you see it changes as you switch between users,**  
**but now it's loaded with help of that resolver.**  
ì´ ì‘ì—…ì„ ì™„ë£Œí•˜ê³  ëª¨ë“  ê²ƒì„ ì €ì¥í•˜ë©´,  
ë‹¤ì‹œ ì´ë™í–ˆì„ ë•Œ ì—¬ì „íˆ `username`ì„  
í™•ì¸í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.  
ê·¸ë¦¬ê³  ì‚¬ìš©ìë¥¼ ì „í™˜í•  ë•Œ  
ê°’ì´ ë³€ê²½ë˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
í•˜ì§€ë§Œ ì´ì œëŠ” ì´ ê°’ì´  
`resolver`ì˜ ë„ì›€ìœ¼ë¡œ ë¡œë“œë©ë‹ˆë‹¤.

#### 43
**And that's of course not a feature you have to use**  
**because as you saw it worked without that as well.**  
**But it is a feature you can use to have leaner components.**  
ë¬¼ë¡ , ë°˜ë“œì‹œ ì‚¬ìš©í•´ì•¼ í•˜ëŠ” ê¸°ëŠ¥ì€ ì•„ë‹™ë‹ˆë‹¤.  
ë³´ì…¨ë‹¤ì‹œí”¼ ì´ ê¸°ëŠ¥ ì—†ì´ë„  
ì‘ë™í–ˆìŠµë‹ˆë‹¤.  
í•˜ì§€ë§Œ ê°„ê²°í•œ ì»´í¬ë„ŒíŠ¸ë¥¼ ë§Œë“¤ê¸° ìœ„í•´  
ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì…ë‹ˆë‹¤.

#### 44
**That's in the end the main advantage.**  
**And you could of course also have multiple resolvers here,**  
**if you had multiple key value pairs,**  
**that would all work.**  
ê²°êµ­ ì´ê²ƒì´ ì£¼ìš” ì¥ì ì…ë‹ˆë‹¤.  
ê·¸ë¦¬ê³  ì—¬ëŸ¬ ê°œì˜ í‚¤-ê°’ ìŒì´ ìˆë‹¤ë©´  
ì—¬ê¸°ì— ì—¬ëŸ¬ ê°œì˜ `resolver`ë¥¼ ì¶”ê°€í•˜ëŠ” ê²ƒë„  
ê°€ëŠ¥í•˜ë©°, ëª¨ë‘ ì˜ ì‘ë™í•  ê²ƒì…ë‹ˆë‹¤.

---

**ë²ˆì—­ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!** ğŸ˜Š ì¶”ê°€ ìš”ì²­ì´ ìˆìœ¼ë©´ ì–¸ì œë“  ë§ì”€í•´ì£¼ì„¸ìš”.
